name: Deploy to QA

on:
  workflow_run:
    workflows: [ "Nightly Build" ]
    types:
      - completed
  workflow_dispatch:

permissions:
  id-token: write   # Needed for OIDC
  contents: read    # Needed to clone repos and read GitHub contents

jobs:
  deploy-qa:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}  # Only run if Nightly Build succeeded
    runs-on: ubuntu-latest
    env:
      AWS_REGION: us-west-2

    steps:
      - name: Checkout Source Repo
        uses: actions/checkout@v4
        with:
          repository: "TiansiGu/JobFitCheker-Source"
          path: "source"  # path in Ubuntu build machine
          ref: dev

      - name: Checkout Infra Repo
        uses: actions/checkout@v4
        with:
          repository: "TiansiGu/JobFitChecker-Infra"
          path: "infra"

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/github-actions-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        run: |
          aws ecr get-login-password --region $AWS_REGION \
          | docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.$AWS_REGION.amazonaws.com

      - name: Make helper scripts executable
        run: chmod +x infra/scripts/*.sh

      - name: Get latest ECR tags and construct IMAGE_URIs
        run: |
          for svc in frontend app postprocessor; do
            REPO_NAME="${{ secrets.ECR_REPO_NAMESPACE }}/$svc"
            LATEST_TAG=$(infra/scripts/get-latest-tag.sh \
              "$REPO_NAME" \
              "$AWS_REGION" \
              "${{ secrets.AWS_ACCOUNT_ID }}" \
              "qa")
            LATEST_TAG_QA="${LATEST_TAG}-qa"

            IMAGE_URI="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${AWS_REGION}.amazonaws.com/$REPO_NAME:$LATEST_TAG_QA"

            VAR_NAME=$(echo "${svc}_image" | tr '[:lower:]' '[:upper:]')
            echo "$VAR_NAME=$IMAGE_URI" >> $GITHUB_ENV
            echo "âœ… $svc â†’ $IMAGE_URI"
          done

      - name: Log resolved ECR image urls
        run: |
          echo "ðŸ–¼ï¸  FRONTEND_IMAGE     = $FRONTEND_IMAGE"
          echo "ðŸ–¼ï¸  APP_IMAGE          = $APP_IMAGE"
          echo "ðŸ–¼ï¸  POSTPROCESSOR_IMAGE = $POSTPROCESSOR_IMAGE"


      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.11.3

      - name: Launch QA EC2 and associated sg
        run: |
          cd infra/terraform/qa
          terraform init
          terraform apply -auto-approve
          PUBLIC_IP=$(terraform output -raw qa_ec2_public_ip)
          S3_BUCKET_NAME=$(terraform output -raw s3_bucket_name)
          SQS_QUEUE_URL=$(terraform output -raw sqs_queue_url)
          echo "PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_ENV
          echo "S3_BUCKET_NAME=$S3_BUCKET_NAME" >> $GITHUB_ENV
          echo "SQS_QUEUE_URL=$SQS_QUEUE_URL" >> $GITHUB_ENV

      - name: Wait for QA EC2 to be ready
        run: sleep 20

      - name: Set up SSH Key
        run: |
          echo "${{ secrets.QA_EC2_SSH_KEY }}" > private-subnet.pem
          chmod 400 private-subnet.pem

      - name: Set up .env for QA
        run: |
          echo "${{ secrets.QA_DOTENV }}" > merged.env

      - name: Merge github secrets, aws resources, and image URIs into one .env file
        run: |
          echo "FRONTEND_IMAGE=$FRONTEND_IMAGE" >> merged.env
          echo "APP_IMAGE=$APP_IMAGE" >> merged.env
          echo "POSTPROCESSOR_IMAGE=$POSTPROCESSOR_IMAGE" >> merged.env
          echo "S3_BUCKET_NAME=$S3_BUCKET_NAME" >> merged.env
          echo "SQS_QUEUE_URL=$SQS_QUEUE_URL" >> merged.env

      - name: Deploy services to QA EC2
        run: |
          REGION=${{ env.AWS_REGION }}
          ACCOUNT_ID=${{ secrets.AWS_ACCOUNT_ID }}
          ACCESS_KEY=${{ env.AWS_ACCESS_KEY_ID }}
          SECRET_KEY=${{ env.AWS_SECRET_ACCESS_KEY }}
          SESSION_TOKEN=${{ env.AWS_SESSION_TOKEN }}

          scp -i private-subnet.pem \
            -o StrictHostKeyChecking=no \
            source/docker-compose-qa.yml \
            ec2-user@${{ env.PUBLIC_IP }}:~/docker-compose.yml

          scp -i private-subnet.pem \
            -o StrictHostKeyChecking=no \
            merged.env \
            ec2-user@${{ env.PUBLIC_IP }}:~/.env

          ssh -i private-subnet.pem \
            -o StrictHostKeyChecking=no \
            ec2-user@${{ env.PUBLIC_IP }} << EOF

              export AWS_ACCOUNT_ID=$ACCOUNT_ID
              export AWS_REGION=$REGION
              export AWS_ACCESS_KEY_ID=$ACCESS_KEY
              export AWS_SECRET_ACCESS_KEY=$SECRET_KEY
              export AWS_SESSION_TOKEN=$SESSION_TOKEN
          
              mkdir -p ~/app
              cp ~/docker-compose-qa.yml ~/app/docker-compose.yml
              cp ~/.env ~/app/.env
              cd ~/app
          
              aws ecr get-login-password --region \$AWS_REGION | docker login \
                --username AWS --password-stdin \$AWS_ACCOUNT_ID.dkr.ecr.\$AWS_REGION.amazonaws.com
          
              docker-compose up -d
              sleep 10
              docker ps
              pwd
          EOF
          
          

#      - name: Destroy EC2 and associated sg
#        run: |
#          cd infra/terraform/qa
#          terraform destroy -auto-approve
          

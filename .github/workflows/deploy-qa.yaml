name: Deploy to QA

on:
  workflow_dispatch:

permissions:
  id-token: write   # Needed for OIDC
  contents: read    # Needed to clone repos and read GitHub contents

jobs:
  deploy-qa:
    runs-on: ubuntu-latest
    env:
      AWS_REGION: us-west-2

    steps:
      - name: Checkout Source Repo
        uses: actions/checkout@v4
        with:
          repository: "TiansiGu/JobFitCheker-Source"
          path: "source"  # path in Ubuntu build machine
          ref: dev

      - name: Checkout Infra Repo
        uses: actions/checkout@v4
        with:
          repository: "TiansiGu/JobFitChecker-Infra"
          path: "infra"

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/github-actions-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        run: |
          aws ecr get-login-password --region $AWS_REGION \
          | docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.$AWS_REGION.amazonaws.com

      - name: Make helper scripts executable
        run: chmod +x infra/scripts/*.sh

      - name: Get latest ECR tags and construct IMAGE_URIs
        run: |
          for svc in frontend app postprocessor; do
            REPO_NAME="${{ secrets.ECR_REPO_NAMESPACE }}/$svc"
            LATEST_TAG=$(infra/scripts/get-latest-qa-tag.sh \
              "$REPO_NAME" \
              "$AWS_REGION" \
              "${{ secrets.AWS_ACCOUNT_ID }}")

            IMAGE_URI="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${AWS_REGION}.amazonaws.com/$REPO_NAME:$LATEST_TAG"

            VAR_NAME=$(echo "${svc}_image" | tr '[:lower:]' '[:upper:]')
            echo "$VAR_NAME=$IMAGE_URI" >> $GITHUB_ENV
            echo "✅ $svc → $IMAGE_URI"
          done

      - name: Log resolved ECR image urls
        run: |
          echo "🖼️  FRONTEND_IMAGE     = $FRONTEND_IMAGE"
          echo "🖼️  APP_IMAGE          = $APP_IMAGE"
          echo "🖼️  POSTPROCESSOR_IMAGE = $POSTPROCESSOR_IMAGE"
          

#      - name: Launch QA EC2 and associated sg
#        run: |
#          cd infra/terraform/qa
#          terraform init
#          terraform apply -auto-approve
#          PUBLIC_IP=$(terraform output -raw qa_ec2_public_ip)
#          echo "PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_ENV
#
#      - name: Set up SSH Key
#        run: |
#          echo "${{ secrets.QA_EC2_SSH_KEY }}" > private-subnet.pem
#          chmod 400 private-subnet.pem
#
#      - name: Set up .env for QA
#        run: |
#          echo "${{ secrets.QA_DOTENV }}" > .env
#          chmod 400 .env
#
#      - name: Deploy services to QA EC2
#        run: |
#          REGION=${{ env.AWS_REGION }}
#          ACCOUNT_ID=${{ secrets.AWS_ACCOUNT_ID }}
#
#          scp -i private-subnet.pem \
#            -o StrictHostKeyChecking=no \
#            source/docker-compose-qa.yml \
#            ec2-user@${{ env.PUBLIC_IP }}:/home/ec2-user/docker-compose.yml
#
#          scp -i private-subnet.pem \
#            -o StrictHostKeyChecking=no \
#            .env \
#            ec2-user@${{ env.PUBLIC_IP }}:/home/ec2-user/
#
#          ssh -i private-subnet.pem \
#            -o StrictHostKeyChecking=no \
#            ec2-user@${{ env.PUBLIC_IP }} << 'EOF'
#
#              export AWS_REGION=${{ env.AWS_REGION }}
#              aws ecr get-login-password --region $REGION | docker login \
#                --username AWS --password-stdin $ACCOUNT_ID.dkr.ecr.$REGION.amazonaws.com
#
#              cd /home/ec2-user
#              docker compose up -d
#          EOF
#
#

#      - name: Destroy EC2 and associated sg
#        run: |
#          cd infra/terraform/qa
#          terraform destroy -auto-approve
          
